imp inputHandler.pypp
imp util.pypp
imp std/strOps.pypp
imp std/fileOps.pypp
imp std/sys.pypp


#include <windows.h>
#include <algorithm>
#include <bits/stdc++.h>

int rows, cols
fn get_terminal_size() void
    %> get terminal size
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
    cols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
end


struct pos {
    int x
    int y
};


const vec<char> auto_close = {'(', '{', '[', '<', '"', '\''};
const vec<char> auto_close_pair = {')', '}', ']', '>', '"', '\''};

struct screen_pos {
    int sx;
    int sy;
};


fn delete_line(strT& file, pos& cursor, bool delete_whole_line = false)
    strvec lines = strOps_split(file, '\n')

    if delete_whole_line && cursor.y > 0
        lines[cursor.y] = ""

        file = strOps_join(lines, '\n')

        cursor.x = 0

        return
    end

    if cursor.y > 0 && lines[cursor.y - 1] != ""
        %> remove newline 
        int newlinel = lines[cursor.y - 1].length()
        cursor.x = std::min(cursor.x, newlinel)
        lines[cursor.y - 1] = lines[cursor.y - 1] + lines[cursor.y]
        cursor.y -= 1
        lines.erase(lines.begin() + (cursor.y + 1))
    elif cursor.y <= lines.size() && cursor.y > 0
        lines.erase(lines.begin() + (cursor.y) - 1) 
    elif cursor.y <= lines.size() && cursor.y == 0
        lines.erase(lines.begin())
    end

    if cursor.y >= lines.size()
        int linessize = lines.size() - 1
        cursor.y = std::max(0, linessize)
    end

    if cursor.x > lines[cursor.y].length()
        cursor.x = lines[cursor.y].length()
    end
    file = strOps_join(lines, '\n')
end


fn delete_word(strT& file, pos& cursor)
    strvec lines = strOps_split(file, '\n')
    strT line = lines[cursor.y]

    int start = cursor.x
    int end = cursor.x

    while start > 0 && line[start - 1] != ' '
        start--
    end

    while end < line.length() && line[end] != ' '
        end++
    end

    lines[cursor.y] = line.substr(0, start) + line.substr(end)

    cursor.x = start

    file = strOps_join(lines, '\n')
end


fn handle_keybindings(strT& file, pos& cursor, char c, strvec& copy_buffer, int& mode)
    if c == 'i'
        mode = 0
        return
    end

    if c == 'a'
        strvec lines = strOps_split(file, '\n')
        cursor.x = lines[cursor.y].length()
        mode = 0
        return
    end

    if c == 'j'
        if cursor.y > 0
            cursor.y -= 1
        end
    elif c == 'k'
        if cursor.y < strOps_split(file, '\n').size() - 1
            cursor.y += 1
        end
    elif c == 'h'
        if cursor.x > 0
            cursor.x -= 1
        end
    elif c == 'l'
        if cursor.x < strOps_split(file, '\n')[cursor.y].length()
            cursor.x += 1
        end
    end

    %> home and end
    if c == 'H'
        cursor.x = 0
        cursor.y = 0
    elif c == 'E'
        cursor.y = strOps_split(file, '\n').size() - 1
        cursor.x = strOps_split(file, '\n')[cursor.y].length()
    end

    if c == 'o'
        cursor.x = 0
    elif c == 'e'
        cursor.x = strOps_split(file, '\n')[cursor.y].length()
    end


    if c == 'y'
        copy_buffer.insert(copy_buffer.begin(), strOps_split(file, '\n')[cursor.y])
    end

    if c == 'd'
        print("\x1b[", rows - (copy_buffer.size() + 1), ";1H")
        strvec lines = strOps_split(file, '\n')
        int idx
        for (int i = 1; i <= copy_buffer.size(); i++) {
            print(i, ": ", copy_buffer[i - 1], "                    \n")
        }

        numinput("> ", idx)
        if idx == 0
            return
        end

        if idx > copy_buffer.size()
            return
        end

        cursor.x = cursor.x > lines[cursor.y].length()? lines[cursor.y].length() : cursor.x

        lines[cursor.y] = lines[cursor.y].substr(0, cursor.x) + copy_buffer[idx - 1] + lines[cursor.y].substr(cursor.x)
        file = strOps_join(lines, '\n')
        cursor.x += copy_buffer[idx - 1].length()
        system("cls")
    end

    if c == 'p'
        if copy_buffer.size() > 0
            strvec lines = strOps_split(file, '\n')
            cursor.x = cursor.x > lines[cursor.y].length()? lines[cursor.y].length() : cursor.x
            lines[cursor.y] = lines[cursor.y].substr(0, cursor.x) + copy_buffer[0] + lines[cursor.y].substr(cursor.x)
            file = strOps_join(lines, '\n')
            cursor.x += copy_buffer[0].length()
        end
    end
    
    if c == 't'
        %> remove everything after the cursor
        strvec lines = strOps_split(file, '\n')
        lines[cursor.y] = lines[cursor.y].substr(0, cursor.x)
        file = strOps_join(lines, '\n')
    end

    if c == 'r'
        %> remove everything before the cursor
        strvec lines = strOps_split(file, '\n')
        lines[cursor.y] = lines[cursor.y].substr(cursor.x)
        cursor.x = 0
        file = strOps_join(lines, '\n')
    end

    if c == 'x'
        strvec lines = strOps_split(file, '\n')
        copy_buffer.insert(copy_buffer.begin(), lines[cursor.y])
        delete_line(file, cursor, true)
    end

    if c == 'w'
        strvec lines = strOps_split(file, '\n')
        delete_word(file, cursor)
    end

    if c == 'f'
        strvec lines = strOps_split(file, '\n')
        strT search = ""
        print("\x1b[", rows - 1, ";1H")
        print("\x1b[K")
        input("Search: ", search)
        search = strOps_trim(search)
        if search == ""
            return
        end

        vec<pos> matches = {};

        for (int i = 0; i < lines.size(); i++) {
            if lines[i].find(search) != -1
                matches.push_back({lines[i].find(search), i})
            end
        }

        print("\x1b[", rows - (matches.size() + 1), ";1H")

        for (int i = 0; i < matches.size(); i++) {
            %> clear current line
            print("\x1b[K")
            print(i + 1, ": ", matches[i].y, ", ", matches[i].x, "\n")
        }

        int idx
        print("\x1b[K")
        numinput("> ", idx)

        if idx == 0
            return
        end

        if idx > matches.size()
            return
        end

        cursor = matches[idx - 1]
    end

    if c == 'g'
        strT replace = ""

        print("\x1b[", rows - 1, ";1H")
        print("\x1b[K")
        input("Replace: ", replace)
        replace = strOps_trim(replace)
        if replace == ""
            return
        end

        strvec lines = strOps_split(file, '\n')

        strT replace_with = strOps_split(replace, '/')[1]
        replace = strOps_split(replace, '/')[0]
        
        for (int i = 0; i < lines.size(); i++) {
            if lines[i].find(replace) != -1
                if replace.rfind('^') == 0
                    replace = replace.substr(replace.rfind('^') + 1)
                    lines[i] = lines[i].substr(0, lines[i].find(replace)) + replace_with + lines[i].substr(lines[i].find(replace) + replace.length())
                else
                    %> replace all, handle multiple replaces
                    strT tmp = ""
                    for (int j = 0; j < lines[i].length(); j++) {
                        if lines[i].substr(j, replace.length()) == replace
                            tmp += replace_with
                            j += replace.length() - 1
                            continue
                        end

                        tmp += lines[i][j]
                    }
                
                    lines[i] = tmp
                end
            end
        }

        file = strOps_join(lines, '\n')
    end
end


fn add_char(strT& file, pos& cursor, char c, strvec& copy_buffer, int& mode)
    if c >= 1 && c <= 26 && c != '\n'
        c = 'a' + c - 1
        handle_keybindings(file, cursor, c, copy_buffer, mode)
        return
    end

    strvec lines = strOps_split(file, '\n')
    int linel = lines[cursor.y].length()
    cursor.x = std::min(cursor.x, linel)
    lines[cursor.y] = lines[cursor.y].substr(0, cursor.x) + c + lines[cursor.y].substr(cursor.x)
    if std::find(auto_close.begin(), auto_close.end(), c) != auto_close.end()
        int i = std::find(auto_close.begin(), auto_close.end(), c) - auto_close.begin()
        lines[cursor.y] = lines[cursor.y].substr(0, cursor.x + 1) + auto_close_pair[i] + lines[cursor.y].substr(cursor.x + 1)
    end

    file = strOps_join(lines, '\n')
    cursor.x += 1
    if cursor.x == cols
        cursor.x = lines[cursor.y].length()
        cursor.y += 1
    end

    if c == '\n'
        cursor.x = 0
        cursor.y += 1
    end
end


fn compute_screen_pos(strvec& lines, pos cursor, int cols, int view_rows, int start) screen_pos
    %> compute screen Y relative to viewport start
    int sy = 0

    %> Count wrapped rows for lines between start and cursor.y-1
    for (int i = start; i < cursor.y; i++) {
        int len = lines[i].length()
        %> how many screen rows this file line consumes (ceil(len / cols)), but at least 1
        int wrapped_rows = (len + cols - 1) / cols
        if wrapped_rows < 1
            wrapped_rows = 1
        end
        sy += wrapped_rows
    }

    %> Now compute wrap index and column inside the cursors line
    int cx = cursor.x
    int wrapIndex = cx / cols
    int wrapCol = cx % cols

    sy += wrapIndex

    %> sy is now screen-row index *relative to the viewport start*
    %> clamp to 0 .. view_rows - 1 (important: view_rows-1, not view_rows)
    if (sy < 0)
        sy = 0
    end
    if (sy > view_rows - 1)
        sy = view_rows - 1
    end

    return { wrapCol, sy };
end


fn main(__argcv__) int
    SetConsoleOutputCP(CP_UTF8)
    get_terminal_size()
    strT file_name = ""
    strT file = ""
    int mode = 3
    pos cursor = {0, 0};
    strvec copy_buffer = {};
    if cols < 75
        print("window too small")
        return 1
    end

    if argc > 1
        if fileOps_exists(argv[1])
            file_name = argv[1]
            file = fileOps_read_file(file_name)
        else
            file_name = argv[1]
        end
    end
    
    forever 
        %> jump to the top and hide the cursor
        print("\x1b[1;1H\x1b[?25l\x1b[0m")
        get_terminal_size()

        if cols < 75
            print("window too small")
        end

        strT EMPTY = ""
        repeat cols
            EMPTY += " "
        end

        %> display file section around cursor
        strvec lines = strOps_split(file, '\n')

        static int start = 0      %> current viewport start
        int total = lines.size()
        int view_rows = rows - 1  %> last row = status bar

        %> ensure cursor is inside the viewport
        if cursor.y < start
            start = cursor.y
        elif cursor.y >= start + view_rows
            start = cursor.y - view_rows + 1
        end

        %> clamp start
        if start < 0
            start = 0
        elif start > total - view_rows
            start = std::max(0, total - view_rows)
        end

        int end = std::min(total, start + view_rows)

        strT slice = ""
        for (int i = start; i < end; i++) {
            strT fill = ""
            repeat cols - lines[i].length()
                fill += " "
            end
            slice += lines[i] + fill
            if i != end - 1
                slice += "\n"
            end
        }

        repeat rows - (end - start) - 1
            slice += EMPTY
        end

        print(slice)

        %> draw status bar
        print("\x1b[", rows, ";1H")

        strT mode_str

        if mode == 0
            mode_str = "INSERT"
        elif mode == 3
            mode_str = "NORMAL"
        end

        strT fstr = ""
        if file_name != ""
            fstr = file_name
        else
            fstr = "untitled"
        end

        %> draw status bar with white background and black text
        print("\x1b[47;30m", mode_str, " | ", cursor.y + 1, "/", total, " | ", fstr, " | ", cols, "x", rows, "\x1b[0m")


        screen_pos cursor_pos = compute_screen_pos(lines, cursor, cols, view_rows, start)
        print("\x1b[", cursor_pos.sy+1, ";", cursor_pos.sx+1, "H")

        %> show cursor
        print("\x1b[?25h")


        char c = inputHandler_get_key()
        if mode == 0
            
            %> if c is escape set mode = 3
            if c == '\x1b'
                mode = 3
                continue
            end


            if c == '\b'
                    strvec lines = strOps_split(file, '\n')
                    if cursor.x > 0
                        lines[cursor.y] = lines[cursor.y].substr(0, cursor.x - 1) + lines[cursor.y].substr(cursor.x)
                        cursor.x -= 1
                        file = strOps_join(lines, '\n')
                    else
                        delete_line(file, cursor)
                    end

            elif c == '\t'
                strvec lines = strOps_split(file, '\n')
                lines[cursor.y] = lines[cursor.y].substr(0, cursor.x) + "    " + lines[cursor.y].substr(cursor.x)
                file = strOps_join(lines, '\n')
                cursor.x += 4
            else
                %> append c to file at cursor
                add_char(file, cursor, c, copy_buffer, mode)
            end

            strT line = strOps_split(file, '\n')[cursor.y]
        elif mode == 3
            handle_keybindings(file, cursor, c, copy_buffer, mode)

            if c == '>'
                system("cls")
                strT command = ""
                input("\n> ", command)
                command = strOps_trim(strOps_lower(command))
                if command == "exit"
                    if file != "" && inputHandler_get_key() == 'y'
                        if file_name != ""
                            fileOps_write_file(file_name, file)
                        else
                            input("\nFile name: ", file_name)
                            file_name = strOps_trim(file_name)
                            fileOps_write_file(file_name, file)
                        end
                    end

                    exit(0)
                elif command == "save"
                    if file_name != ""
                        fileOps_write_file(file_name, file)
                    else
                        input("\nFile name: ", file_name)
                        file_name = strOps_trim(file_name)
                        fileOps_write_file(file_name, file)
                    end
                elif command == "open"
                    if file_name != ""
                        fileOps_write_file(file_name, file)
                    end

                    input("\nFile name: ", file_name)
                    file_name = strOps_trim(file_name)
                    
                    if fileOps_exists(file_name)
                        file = fileOps_read_file(file_name)
                    else
                        file = ""
                    end
                elif command == "help"
                    system("cls")

                    print("Commands:\n")
                    print("\n")
                    print("exit - exit the program\n")
                    print("save - save the file\n")
                    print("open - open a file\n")
                    print("help - show this help message\n")
                    print("\n")

                    print("Keys:\n")
                    print("\n")
                    print("j - move cursor up\n")
                    print("k - move cursor down\n")
                    print("h - move cursor left\n")
                    print("l - move cursor right\n")
                    print("H - move cursor to the top of the file\n")
                    print("E - move cursor to the end of the file\n")
                    print("o - move cursor to the start of the line\n")
                    print("e - move cursor to the end of the line\n")
                    print("y - copy line\n")
                    print("d - paste line\n")
                    print("p - paste\n")
                    print("t - remove everything after the cursor\n")
                    print("r - remove everything before the cursor\n")
                    print("^key - use these keybinds in insert mode\n")
                    print("i - insert\n")
                    print("a - append\n")
                    print("ESC - normal")
                    print("\n")

                    print("press any key to continue")
                    getch()
                end

                system("cls")
            end
        end
    end
end